"use client"

import type React from "react"
import {useCallback, useEffect, useRef, useState} from "react"
import Link from "next/link"
import {usePathname} from "next/navigation"
import {Search, X} from "lucide-react"
import {ChevronDown, ChevronRight} from "@carbon/icons-react"
import styles from "./sidebar.module.css"

interface NavItem {
  title: string
  path: string
  children?: NavItem[]
}

interface CarbonSidebarProps {
  isMobileOpen: boolean
  onCloseMobile: () => void
}

const navigationStructure: NavItem[] = [
  {
    title: "v0plex: A Theme Generated by v0.dev",
    path: "/v0plex",
    children: [
      {
        title: "What Is v0plex And How It Is Generated",
        path: "/abt_v0p",
        children: [
          {title: "Ideas From IBM Carbon Design Systems", path: "/v0plex/abt_v0p/ideas_from_ibm_carbon"},
          {title: "Rising Of Generated LLM - Use v0.dev", path: "/v0plex/abt_v0p/v0dev"},
          {
            title: "Limitations & Disadvantages Of Main Stream Blog Framework",
            path: "/v0plex/abt_v0p/limitation_of_mainstream_blogs_framework"
          },
          {title: "Future Works For v0plex", path: "/v0plex/abt_v0p/future_works"},
        ]
      },
      {
        title: "v0plex Example Pages",
        path: "/example_pages",
        children: [
          {title: "Exampled Use Case 1", path: "/v0plex/example_pages/test-1"},
          {title: "Exampled Use Case 2", path: "/v0plex/example_pages/test-2"},
          {title: "Exampled Use Case 3", path: "/v0plex/example_pages/test-3"},
        ]
      },
      {
        title: "v0plex Components",
        path: "/v0plex_components",
        children: [
          {title: "To Be Continued", path: "/v0plex/v0plex_components/todo"},
        ]
      }
    ],
  },
  {
    title: "Chinese Archive Blogs Before 2022",
    path: "/before_graduate",
    children: [
      {title: "C++中的裸指针", path: "/before_graduate/learning_raw_pointer_in_cpp"},
      {title: "智能指针之shared_ptr", path: "/before_graduate/learning_shared_pointer_in_cpp"},
      {title: "Operator Overloading原理", path: "/before_graduate/learning_operator_overloading_in_cpp"},
    ],
  },
  
  // {
  //   title: "Test Folder 1",
  //   path: "/test-folder-1",
  //   children: [
  //     {
  //       title: "Test Folder 2",
  //       path: "/test-folder-1/test-folder-2",
  //       children: [
  //         { title: "Test Folder 3", path: "/test-folder-1/test-folder-2/test-folder-3" },
  //         { title: "Test Folder 4", path: "/test-folder-1/test-folder-2/test-folder-4" },
  //         {
  //           title: "Test Folder 5",
  //           path: "/test-folder-1/test-folder-2/test-folder-5",
  //           children: [{ title: "Test 4", path: "/test-folder-1/test-folder-2/test-folder-5/test-4" }],
  //         },
  //       ],
  //     },
  //   ],
  // },
]

function flattenNavigation(items: NavItem[]): NavItem[] {
  const result: NavItem[] = []
  
  function traverse(items: NavItem[]) {
    for (const item of items) {
      result.push(item)
      if (item.children) {
        traverse(item.children)
      }
    }
  }
  
  traverse(items)
  return result
}

// 检查当前路径是否是活动的页面链接（不是文件夹）
function isActivePage(pathname: string, item: NavItem): boolean {
  // 如果有子项，说明是文件夹，不应该有活动状态
  if (item.children && item.children.length > 0) {
    return false
  }
  
  // 标准化路径 - 移除尾部斜杠，但保留根路径的斜杠
  const normalizePath = (path: string) => {
    return path.replace(/\/$/, "") || "/"
  }
  
  const normalizedPathname = normalizePath(pathname)
  const normalizedItemPath = normalizePath(item.path)
  
  // 精确匹配路径
  return normalizedPathname === normalizedItemPath
}

// 检查文件夹是否包含活动页面（用于自动展开）
function hasActiveChild(pathname: string, item: NavItem): boolean {
  if (!item.children || item.children.length === 0) {
    return false
  }
  
  return item.children.some(child =>
    isActivePage(pathname, child) || hasActiveChild(pathname, child)
  )
}

// 检查是否应该展开某个文件夹
function shouldExpand(pathname: string, item: NavItem, manuallyExpandedItems: Set<string>, manuallyCollapsedItems: Set<string>): boolean {
  if (!item.children || item.children.length === 0) {
    return false
  }
  
  // 如果用户手动收起了，就不展开（优先级最高）
  if (manuallyCollapsedItems.has(item.path)) {
    return false
  }
  
  // 如果用户手动展开了，就展开
  if (manuallyExpandedItems.has(item.path)) {
    return true
  }
  
  // 否则，检查是否有活动子项（自动展开）
  return hasActiveChild(pathname, item)
}

// @ts-ignore
export default ({isMobileOpen, onCloseMobile}: CarbonSidebarProps) => {
  const [searchQuery, setSearchQuery] = useState("")
  const [manuallyExpandedItems, setManuallyExpandedItems] = useState<Set<string>>(new Set())
  const [manuallyCollapsedItems, setManuallyCollapsedItems] = useState<Set<string>>(new Set())
  const [sidebarWidth, setSidebarWidth] = useState(256)
  const [isResizing, setIsResizing] = useState(false)
  const sidebarRef = useRef<HTMLDivElement>(null)
  const pathname = usePathname()
  
  // 当路径变化时，清除手动收起的状态（只对包含新活动页面的文件夹）
  useEffect(() => {
    setManuallyCollapsedItems(prev => {
      const newSet = new Set(prev)
      
      // 清除包含当前活动页面的文件夹的手动收起状态
      const clearCollapsedForActiveParents = (items: NavItem[]) => {
        for (const item of items) {
          if (item.children && hasActiveChild(pathname, item)) {
            newSet.delete(item.path)
          }
          if (item.children) {
            clearCollapsedForActiveParents(item.children)
          }
        }
      }
      
      clearCollapsedForActiveParents(navigationStructure)
      return newSet
    })
  }, [pathname])
  
  const allItems = flattenNavigation(navigationStructure)
  const filteredItems = allItems.filter(
    (item) =>
      item.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      item.path.toLowerCase().includes(searchQuery.toLowerCase()),
  )
  
  const updateSidebarWidth = useCallback((width: number) => {
    const clampedWidth = Math.max(200, Math.min(600, width))
    setSidebarWidth(clampedWidth)
    document.documentElement.style.setProperty("--sidebar-width", `${clampedWidth}px`)
  }, [])
  
  useEffect(() => {
    updateSidebarWidth(sidebarWidth)
  }, [sidebarWidth, updateSidebarWidth])
  
  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault()
      setIsResizing(true)
      
      const handleMouseMove = (e: MouseEvent) => {
        updateSidebarWidth(e.clientX)
      }
      
      const handleMouseUp = () => {
        setIsResizing(false)
        document.removeEventListener("mousemove", handleMouseMove)
        document.removeEventListener("mouseup", handleMouseUp)
      }
      
      document.addEventListener("mousemove", handleMouseMove)
      document.addEventListener("mouseup", handleMouseUp)
    },
    [updateSidebarWidth],
  )
  
  const toggleExpanded = (path: string) => {
    const currentlyExpanded = shouldExpand(pathname, navigationStructure.find(item => item.path === path) || {
      title: '',
      path: ''
    }, manuallyExpandedItems, manuallyCollapsedItems)
    
    if (currentlyExpanded) {
      // 如果当前是展开的，收起它
      setManuallyExpandedItems(prev => {
        const newSet = new Set(prev)
        newSet.delete(path)
        return newSet
      })
      setManuallyCollapsedItems(prev => new Set(prev).add(path))
    } else {
      // 如果当前是收起的，展开它
      setManuallyCollapsedItems(prev => {
        const newSet = new Set(prev)
        newSet.delete(path)
        return newSet
      })
      setManuallyExpandedItems(prev => new Set(prev).add(path))
    }
  }
  
  const clearSearch = () => {
    setSearchQuery("")
  }
  
  const handleItemClick = (item: NavItem, e: React.MouseEvent) => {
    const hasChildren = item.children && item.children.length > 0
    
    if (hasChildren) {
      // 如果有子项，阻止默认的链接跳转，改为展开/折叠
      e.preventDefault()
      toggleExpanded(item.path)
    } else {
      // 如果没有子项，正常跳转并关闭移动端侧边栏
      onCloseMobile()
    }
  }
  
  const renderNavItem = (item: NavItem, level = 0) => {
    const isActive = isActivePage(pathname, item)
    const isExpanded = shouldExpand(pathname, item, manuallyExpandedItems, manuallyCollapsedItems)
    const hasChildren = item.children && item.children.length > 0
    const paddingLeft = `${0.75 + level}rem`
    
    return (
      <div key={item.path}>
        <div
          className={`${styles.navItem} ${isActive ? styles.active : ""} ${hasChildren ? styles.hasChildren : ""}`}
          style={{paddingLeft}}
        >
          {hasChildren ? (
            // 如果有子项，整个区域都是可点击的按钮
            <button
              className={styles.navItemButton}
              onClick={(e) => handleItemClick(item, e)}
              aria-label={isExpanded ? "Collapse" : "Expand"}
            >
              <span className={styles.navItemText}>{item.title}</span>
              <span className={styles.navItemChevron}>
                {isExpanded ? <ChevronDown size={12}/> : <ChevronRight size={12}/>}
              </span>
            </button>
          ) : (
            // 如果没有子项，使用普通链接
            <Link href={item.path} className={styles.navItemLink} onClick={onCloseMobile}>
              <span className={styles.navItemText}>{item.title}</span>
            </Link>
          )}
        </div>
        {hasChildren && isExpanded && <div>{item.children?.map((child) => renderNavItem(child, level + 1))}</div>}
      </div>
    )
  }
  
  return (
    <>
      <div
        ref={sidebarRef}
        className={`${styles.sidebar} ${isMobileOpen ? styles.mobileOpen : ""}`}
        style={{width: `${sidebarWidth}px`}}
      >
        <div className={styles.searchSection}>
          <div className={styles.searchContainer}>
            <Search className={styles.searchIcon}/>
            <input
              type="text"
              placeholder="Search articles..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className={styles.searchInput}
            />
            {searchQuery && (
              <button onClick={clearSearch} className={styles.searchClearButton} aria-label="Clear search">
                <X size={12}/>
              </button>
            )}
          </div>
        </div>
        
        <div className={styles.navigationContent}>
          {searchQuery ? (
            <div className={styles.searchResults}>
              <div className={styles.searchResultsHeader}>Search Results ({filteredItems.length})</div>
              <div className={styles.searchResultsList}>
                {filteredItems.length > 0 ? (
                  filteredItems.map((item) => (
                    <div
                      key={item.path}
                      className={`${styles.searchResultItem} ${isActivePage(pathname, item) ? styles.active : ""}`}
                    >
                      <Link href={item.path} className={styles.searchResultLink} onClick={onCloseMobile}>
                        <div className={styles.searchResultTitle}>{item.title}</div>
                        <div className={styles.searchResultPath}>{item.path}</div>
                      </Link>
                    </div>
                  ))
                ) : (
                  <div className={styles.noResults}>No results found</div>
                )}
              </div>
            </div>
          ) : null}
          
          <div className={styles.directoryStructure}>
            <div className={styles.allArticlesHeader}>All Articles</div>
            {navigationStructure.map((item) => renderNavItem(item))}
          </div>
        </div>
        
        <div className={`${styles.resizeHandle} ${isResizing ? styles.resizing : ""}`} onMouseDown={handleMouseDown}/>
      </div>
      
      {isMobileOpen && (
        <div className={`${styles.mobileOverlay} ${isMobileOpen ? styles.show : ""}`} onClick={onCloseMobile}/>
      )}
    </>
  )
}